#!/usr/bin/env python3

import os
import sys
import time
import toml
import argparse
import subprocess

# 获取当前配置的系统类型，默认为 'lsf'
def get_system_type():
    config_path = os.path.expanduser('~/.jsub.config')
    if os.path.exists(config_path):
        try:
            config = toml.load(config_path)
            return config.get('general', {}).get('system', 'lsf').lower()
        except:
            return 'lsf'
    return 'lsf'

def create_job(script_path, system_type):
    # make a tmp sub file
    tmp_sub_path = os.path.expanduser('~/.jsub.tmp')
    # 获取日志文件的绝对路径
    errlog_path = os.path.expanduser('~/.jsub.errlog')
    # 定义一个专门用于捕捉调度系统（如启动失败）信息的日志
    daemon_log_path = os.path.expanduser('~/.jsub.daemon.log')
    
    with open(tmp_sub_path, 'w') as f:
        f.write("#!/bin/bash\n") # Slurm 最好加上 shebang
        
        if system_type == 'slurm':
            f.write("#SBATCH -J jsub_daemon\n")
            f.write("#SBATCH -p single\n") # 注意：Slurm的分区名可能不同，需根据集群调整
            f.write("#SBATCH -o {daemon_log_path}\n")
            f.write("#SBATCH -e {daemon_log_path}\n")
            f.write("#SBATCH -n 1\n")
            f.write("#SBATCH --ntasks-per-node=1\n")
        else: # Default to LSF
            f.write("#BSUB -J jsub_daemon\n")
            f.write("#BSUB -q small\n")
            f.write("#BSUB -oo {daemon_log_path}\n")
            f.write("#BSUB -eo {daemon_log_path}\n")
            f.write("#BSUB -n 2\n")
            f.write("#BSUB -R span[ptile=2]\n")
        
        f.write("\n")
        # 打印启动时间方便调试
        f.write(f'echo "Daemon started at $(date)" >> {errlog_path}\n')
        f.write(f"python3 -u {script_path} QV62dayWhfpq0XmTcpWGFyDmORFBwyTIRxZvzZLi8H2bw9SI > {daemon_log_path} 2>&1 \n")
        f.write("\n")
    
    # submit the tmp sub file
    if system_type == 'slurm':
        os.system(f"sbatch {tmp_sub_path}")
    else:
        os.system(f"bsub < {tmp_sub_path}")
        
    #remove the tmp sub file
    # Slurm 提交后有时文件删除过快会报错，稍微sleep一下比较稳妥，或者不删由系统清理
    time.sleep(1) 
    if os.path.exists(tmp_sub_path):
        os.remove(tmp_sub_path)


def find_bsubs(path):
    bsub_files = []
    valid_extensions = ['.bsub', '.slurm', '.job', 'lsf'] # 扩充识别的后缀
    # check if the path is a directory
    if os.path.isdir(path):
        # iterate through all files in the directory
        for root, dirs, files in os.walk(path):
            for file in files:
                if any(file.endswith(ext) for ext in valid_extensions):
                    bsub_files.append(os.path.join(root, file))
    return bsub_files


def add_job(bsub_path, recursive):
    # load in config file
    config_path = os.path.expanduser('~/.jsub.config')
    # 确保配置存在，如果不存在先让main函数去初始化
    if not os.path.exists(config_path):
        print("Config file not found. Please run 'jsub init' first or just run jsub once to generate it.")
        # 这里为了简单，如果不存在我们就先不管，假设调用add_job前已经有配置了
        # 实际逻辑中，main函数会处理配置生成
    
    config = toml.load(config_path)
    
    if recursive:
        # check if the bsub file is a directory
        if not os.path.isdir(bsub_path):
            raise ValueError(f"Path '{bsub_path}' is not a directory.")
        # get all bsub files in the directory
        bsub_files = find_bsubs(bsub_path)
        if not bsub_files:
            print(f"No job script files found in the directory '{bsub_path}'.")
            exit(0)
        # add all bsub files to the config file
        for bsub_file in bsub_files:
            # get real path of the bsub file
            bsub_real_path = os.path.realpath(bsub_file)
            # check if the bsub file is already in the config file
            if bsub_real_path in config['jobs']:
                print(f"Job file '{bsub_real_path}' is already in the config file.")
                continue
            # add the bsub file to the config file
            config['jobs'][bsub_real_path] = 0
        with open(config_path, 'w') as f:
            toml.dump(config, f)
        print(f"Added {len(bsub_files)} job files to the job list.")
    else:
        # check if the bsub file exists
        if not os.path.exists(bsub_path):
            raise FileNotFoundError(f"Job file '{bsub_path}' does not exist.")
        # get real path of the bsub file
        bsub_real_path = os.path.realpath(bsub_path)
        # check if the bsub file is already in the config file
        if bsub_real_path in config['jobs']:
            print(f"Job file '{bsub_real_path}' is already in the config file.")
            exit(0)
        # add the bsub file to the config file
        config['jobs'][bsub_real_path] = 0
        with open(config_path, 'w') as f:
            toml.dump(config, f)


def submit_job(bsub_path, system_type):
    success_mark = False
    count = 0
    curr_dir = os.getcwd()
    
    if system_type == 'slurm':
        success_str = "Submitted batch job"
    else:
        success_str = "is submitted to queue"

    while not success_mark:
        bsub_dir = os.path.dirname(bsub_path)
        # 如果路径是单纯文件名，dirname为空，chdir会报错，加个判断
        if bsub_dir:
            os.chdir(bsub_dir)
        
        output = ""
        error_msg = ""
        
        try:
            if system_type == 'slurm':
                # 兼容 py3.6
                res = subprocess.run(["sbatch", bsub_path], stdout=subprocess.PIPE, stderr=subprocess.PIPE, universal_newlines=True)
            else:
                # LSF
                with open(bsub_path, 'r') as f:
                    res = subprocess.run(["bsub"], stdin=f, stdout=subprocess.PIPE, stderr=subprocess.PIPE, universal_newlines=True)
            
            output = res.stdout
            error_msg = res.stderr
            
        except Exception as e:
            error_msg = str(e)
            
        if success_str in output:
            success_mark = True
        else:
            count += 1
            time.sleep(5)
        
        if count >= 10:
            errlog_path = os.path.expanduser('~/.jsub.errlog')
            with open(errlog_path, 'a') as errlog:
                errlog.write(f"{time.strftime('%Y-%m-%d %H:%M:%S')} - \n")
                errlog.write(f"Failed to submit job '{bsub_path}' after 10 attempts using {system_type}.\n")
                if output.strip(): errlog.write(f"Stdout: {output.strip()}\n")
                if error_msg.strip(): errlog.write(f"Stderr: {error_msg.strip()}\n")
            
            os.chdir(curr_dir)
            print(f"Skipping job {bsub_path} due to submission failure.")
            return False
            
    os.chdir(curr_dir)
    return True


def run_jobs(config):
    errlog_path = os.path.expanduser('~/.jsub.errlog')
    config_path = os.path.expanduser('~/.jsub.config')
    system_type = config['general'].get('system', 'lsf').lower()

    # --- 1. 获取当前任务数 (兼容 Python 3.6 写法) ---
    current_job_nums = 99999 
    try:
        # 获取用户名
        user = os.environ.get('USER')
        if not user:
            # 兼容 py3.6: 使用 stdout=subprocess.PIPE, universal_newlines=True
            res_user = subprocess.run(["whoami"], stdout=subprocess.PIPE, stderr=subprocess.PIPE, universal_newlines=True)
            user = res_user.stdout.strip()
        
        if system_type == 'slurm':
            # Slurm: squeue
            # 关键修改：去掉 capture_output=True, 改用旧式写法
            cmd = f"squeue -u {user} -h"
            res = subprocess.run(cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, universal_newlines=True)
            
            if res.returncode == 0:
                # 成功获取，过滤空行
                lines = [l for l in res.stdout.split('\n') if l.strip()]
                current_job_nums = len(lines)
            else:
                # 命令执行失败（如 squeue 报错），打印警告以便调试
                print(f"Warning: squeue failed. Stderr: {res.stderr.strip()}")
                
        else:
            # LSF: bjobs
            res = subprocess.run(["bjobs", "-w"], stdout=subprocess.PIPE, stderr=subprocess.PIPE, universal_newlines=True)
            if res.returncode == 0:
                lines = res.stdout.splitlines()
                current_job_nums = len(lines) - 1 if len(lines) > 0 else 0
                if current_job_nums < 0: current_job_nums = 0
            else:
                 print(f"Warning: bjobs failed. Stderr: {res.stderr.strip()}")

    except Exception as e:
        # 打印异常信息，防止默默失败
        print(f"Error checking queue: {e}")
        # current_job_nums 保持 99999

    # 计算配额
    sub_num = config['general']['max_jobs'] - current_job_nums + 1
    
    # 如果 sub_num <= 0，说明队列满了或查询失败，打印一下状态
    # if sub_num <= 0:
    #    print(f"Queue full or check failed (Current: {current_job_nums}, Max: {config['general']['max_jobs']}). Waiting...")

    queued_jobs = list(config['jobs'].keys())
    sub_count = 0
    fail_count = 0 

    if sub_num > 0 and len(queued_jobs) > 0:
        for bsub_path in queued_jobs:
            if not os.path.exists(bsub_path):
                # 记录日志并删除不存在的文件
                with open(errlog_path, 'a') as errlog:
                    errlog.write(f"{time.strftime('%Y-%m-%d %H:%M:%S')} - Job file '{bsub_path}' does not exist. Skipping.\n")
                del config['jobs'][bsub_path]
                continue
                
            # 投递
            if submit_job(bsub_path, system_type):
                sub_count += 1
                del config['jobs'][bsub_path]
            else:
                fail_count += 1
            
            # 达到本轮限额则退出循环
            if (sub_count + fail_count) >= sub_num:
                break
                
    if sub_count != 0 or len(queued_jobs) != len(config['jobs']):
        with open(config_path, 'w') as f:
            toml.dump(config, f)
            
    return fail_count


def main():
    parser = argparse.ArgumentParser(
        description="\t心急吃不了热豆腐\n\t\t\t-----zyl 250618",
        formatter_class=argparse.RawDescriptionHelpFormatter
    )
    parser.add_argument('-S', action='store_true', help='Silent mode, do not print any output.')
    parser.add_argument('-r', action='store_true', help='ONLY for adding jobs, will treat the bsub as a search path, and add all job files in the path to the job list.') 
    parser.add_argument('bsub', type=str, help='Your job file to submit. If named "init", will start a job to sub all piled jobs.')
    args = parser.parse_args()
    
    # check if current user has the config file
    config_path = os.path.expanduser('~/.jsub.config')
    if not os.path.exists(config_path):
        template_config = {
            'general': {
                'system': 'lsf', # 新增 system 字段
                'scanning_interval': 60,
                'max_jobs': 50
            },
            'jobs': {}
        }
        with open(config_path, 'w') as f:
            toml.dump(template_config, f)
            
    # check the config is a valid toml file
    try:
        config = toml.load(config_path)
    except toml.TomlDecodeError:
        raise ValueError(f"Config file '{config_path}' is not a valid TOML file. Please check the syntax.")
    
    # 确保 config 里有 system 字段 (针对旧 config 文件的兼容)
    if 'system' not in config['general']:
        config['general']['system'] = 'lsf'
        with open(config_path, 'w') as f:
            toml.dump(config, f)

    system_type = config['general']['system']

    # if the bsub file is "init", start a job to sub all piled jobs
    if args.bsub == 'init':
        # get the script path
        script_path = os.path.realpath(__file__)
        create_job(script_path, system_type) # 传入 system_type
        if not args.S:
            print(f"Job to submit all piled jobs has been created ({system_type}). Please wait for it to run.")
    elif args.bsub == 'QV62dayWhfpq0XmTcpWGFyDmORFBwyTIRxZvzZLi8H2bw9SI':
        # 【新增】守护进程启动时的自检打印
        print(f"Daemon process started. PID: {os.getpid()}")
        print(f"Loaded config from: {config_path}")
        
        # 重新加载一次以确保最新
        config = toml.load(config_path)
        job_count = len(config['jobs'])
        print(f"Initial job count in queue: {job_count}")
        
        if job_count == 0:
            print("Warning: Job list is empty. Daemon will exit immediately.")
            # 可以在这里决定是否要 exit，或者 sleep 等待（原逻辑是退出）
        
        consecutive_fails = 0
        MAX_TOLERANCE = 3
        
        while len(config['jobs']) != 0:
            print(f"--- Starting new cycle at {time.strftime('%H:%M:%S')} ---") # 心跳包
            
            # 重新加载 config
            config = toml.load(config_path)
            
            # 运行任务
            fails_in_this_round = run_jobs(config)
            
            if fails_in_this_round > 0:
                consecutive_fails += fails_in_this_round
                print(f"Warning: {fails_in_this_round} jobs failed in this cycle. Total consecutive: {consecutive_fails}")
            else:
                consecutive_fails = 0
                print("Cycle completed successfully.")
            
            if consecutive_fails >= MAX_TOLERANCE:
                err_msg = f"CRITICAL: Jsub daemon stopped! {consecutive_fails} consecutive submission failures."
                print(err_msg)
                with open(os.path.expanduser('~/.jsub.errlog'), 'a') as f:
                    f.write(f"{time.strftime('%Y-%m-%d %H:%M:%S')} - {err_msg}\n")
                exit(1)
            
            print(f"Sleeping for {config['general']['scanning_interval']} seconds...")
            time.sleep(config['general']['scanning_interval'])
            
        print("Job queue is empty. Daemon execution finished.") # 正常退出日志
        
    else:
        add_job(args.bsub, args.r)
        if not args.S:
            print(f"Successfully added '{args.bsub}' to the job list.")

if __name__ == "__main__":
    main()
